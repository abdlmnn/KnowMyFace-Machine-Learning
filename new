import os
import sqlite3
import numpy as np
import io
import base64
import pickle
import cv2
from concurrent.futures import ThreadPoolExecutor
from flask import Flask, render_template, request, jsonify
from flask_socketio import SocketIO, emit
from PIL import Image
from scipy.spatial.distance import cosine
from deepface import DeepFace
from mtcnn import MTCNN

app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins="*", max_http_buffer_size=1000000)

# ----------------- Database -----------------
DB_PATH = "test.db"
SAVE_DIR = "registered_faces"
os.makedirs(SAVE_DIR, exist_ok=True)

def get_db_connection():
    return sqlite3.connect(DB_PATH)

conn = get_db_connection()
cursor = conn.cursor()
cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS user_embeddings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    embedding BLOB,
    FOREIGN KEY(user_id) REFERENCES users(id)
);
""")
conn.commit()
conn.close()

# ----------------- Face Detector -----------------
detector = MTCNN()

# ----------------- Tracking -----------------
previous_faces = []  # {"tracker", "bbox_small", "name", "embedding", "lost", "count"}
STABLE_FRAMES = 3
FRAME_SKIP = 5
frame_counter = 0

# ----------------- Thread Pool -----------------
executor = ThreadPoolExecutor(max_workers=4)

# ----------------- Embedding Cache -----------------
db_embeddings = []  # (user_id, embedding)
db_user_map = {}    # user_id -> name

def load_embeddings_cache():
    global db_embeddings, db_user_map
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT u.id, u.name, e.embedding FROM users u JOIN user_embeddings e ON u.id=e.user_id")
    db_embeddings = []
    db_user_map = {}
    for uid, name, emb in cursor.fetchall():
        db_embeddings.append((uid, pickle.loads(emb)))
        db_user_map[uid] = name
    conn.close()

load_embeddings_cache()

# ----------------- Routes -----------------
@app.route('/')
def index():
    return render_template("index.html")

@app.route('/register')
def register():
    return render_template("register.html")

@app.route('/register_face', methods=['POST'])
def register_face():
    data = request.get_json()
    name = data.get('name')
    images = data.get('images')

    if not name or not images:
        return jsonify({"message": "Name and images required"}), 400

    # Create folder for this user
    person_dir = os.path.join(SAVE_DIR, name)
    os.makedirs(person_dir, exist_ok=True)

    embeddings_list = []
    for i, img_data in enumerate(images):
        img_str = img_data.split(',')[1]
        img_bytes = base64.b64decode(img_str)
        img = Image.open(io.BytesIO(img_bytes)).convert('RGB')
        frame = np.array(img)

        # Save original image
        img_path = os.path.join(person_dir, f"{name}_{i+1}.jpg")
        img.save(img_path)

        faces = detector.detect_faces(frame)
        if len(faces) == 0:
            continue

        for face in faces:
            x, y, w, h = face['box']
            x, y = max(0, x), max(0, y)
            face_img = frame[y:y+h, x:x+w]
            face_img = cv2.resize(face_img, (96, 96))

            try:
                embedding = DeepFace.represent(
                    face_img,
                    model_name='OpenFace',
                    enforce_detection=False,
                    detector_backend='opencv'
                )[0]["embedding"]
                embeddings_list.append(embedding)
            except:
                continue

    if len(embeddings_list) == 0:
        return jsonify({"message": "No valid faces detected"}), 400

    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("INSERT OR IGNORE INTO users (name) VALUES (?)", (name,))
    conn.commit()
    cursor.execute("SELECT id FROM users WHERE name=?", (name,))
    user_id = cursor.fetchone()[0]

    for emb in embeddings_list:
        cursor.execute("INSERT INTO user_embeddings (user_id, embedding) VALUES (?, ?)", (user_id, pickle.dumps(emb)))
    conn.commit()
    conn.close()

    # Update cache
    for emb in embeddings_list:
        db_embeddings.append((user_id, emb))
    db_user_map[user_id] = name

    return jsonify({"message": f"Successfully registered {len(embeddings_list)} embeddings for {name}!"})

# ----------------- Recognition -----------------
def recognize_face(face_img, face_dict):
    try:
        face_resized = cv2.resize(face_img, (96, 96))
        embedding = DeepFace.represent(
            face_resized,
            model_name='OpenFace',
            enforce_detection=False,
            detector_backend='opencv'
        )[0]['embedding']

        face_dict['embedding'] = embedding
        recognized_name = "Unknown"
        min_dist = 0.45

        for user_id, db_emb in db_embeddings:
            dist = cosine(embedding, db_emb)
            if dist < min_dist:
                min_dist = dist
                recognized_name = db_user_map.get(user_id, "Unknown")

        face_dict['name'] = recognized_name
    except:
        face_dict['name'] = "Unknown"

# ----------------- Live Recognition -----------------
@socketio.on('frame')
def handle_frame(data):
    global previous_faces, frame_counter
    img_data = data.get('image')
    if not img_data:
        emit('faces', {"faces": []})
        return

    img_str = img_data.split(',')[1]
    img_bytes = base64.b64decode(img_str)
    img = Image.open(io.BytesIO(img_bytes)).convert('RGB')
    frame_full = np.array(img)

    scale = 0.5
    frame_small = cv2.resize(frame_full, (0, 0), fx=scale, fy=scale)
    frame_counter += 1

    for f in previous_faces:
        success, bbox = f['tracker'].update(frame_small)
        f['bbox_small'] = bbox if success else f['bbox_small']
        f['lost'] = 0 if success else f.get('lost', 0) + 1
    previous_faces[:] = [f for f in previous_faces if f['lost'] < 2]

    if frame_counter % FRAME_SKIP == 0 or len(previous_faces) == 0:
        detected = detector.detect_faces(frame_small)
        for det in detected:
            x, y, w, h = det['box']
            if any(abs(f['bbox_small'][0]-x)<30 and abs(f['bbox_small'][1]-y)<30 for f in previous_faces):
                continue

            tracker = cv2.TrackerKCF_create()
            tracker.init(frame_small, (x, y, w, h))
            face_dict = {"tracker": tracker, "bbox_small": (x, y, w, h), "name": "Unknown", "embedding": None, "lost": 0, "count": 0}

            x_full, y_full, w_full, h_full = int(x/scale), int(y/scale), int(w/scale), int(h/scale)
            face_img = frame_full[y_full:y_full+h_full, x_full:x_full+w_full]

            # Save recognition frame to user folder if recognized
            def recognize_and_save(f_img, f_obj):
                recognize_face(f_img, f_obj)
                if f_obj['name'] != "Unknown":
                    person_dir = os.path.join(SAVE_DIR, f_obj['name'])
                    os.makedirs(person_dir, exist_ok=True)
                    save_path = os.path.join(person_dir, f"capture_{np.random.randint(10000)}.jpg")
                    Image.fromarray(f_img).save(save_path)

            executor.submit(lambda f_img=face_img, f_obj=face_dict: recognize_and_save(f_img, f_obj))
            previous_faces.append(face_dict)

    output_faces = []
    for f in previous_faces:
        x, y, w, h = f['bbox_small']
        x_disp, y_disp, w_disp, h_disp = int(x/scale), int(y/scale), int(w/scale), int(h/scale)
        f.setdefault('prev_name', f.get('name', 'Unknown'))
        f.setdefault('count', 0)

        if f['name'] == f['prev_name']:
            f['count'] += 1
        else:
            f['count'] = 0
            f['prev_name'] = f['name']

        display_name = f['name'] if f['count'] >= STABLE_FRAMES else f['prev_name']
        output_faces.append({"x": x_disp, "y": y_disp, "w": w_disp, "h": h_disp, "name": display_name})

    emit('faces', {"faces": output_faces})

# ----------------- Run App -----------------
if __name__ == "__main__":
    socketio.run(app, host="127.0.0.1", port=5001, debug=True)
